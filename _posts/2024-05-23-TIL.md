---
layout: single
title: "내일배움캠프 27일차 5/23 TIL + Unity공부 + 팀프로젝트"
permalink: /2024/05/23/TIL/
tags: [TIL, 내일배움캠프, 스파르타내일배움캠프, 스파르타내일배움캠프TIL, Unity]
---

# Coroutines
코루틴은 한번에 다 처리하지말고 시간을 들여 처리할 일이 있을 때 쓰는 방법이다.  

## 작동 방법
코루틴은 IEnumerator를 return한다.  
IEnumerator는 System.Collections에 있는 namespace로 yield로 return하며 반복작업을 할 때 사용됩니다.   
코루틴은 안에 있는 로컬 변수들이 yield한 동안에도 유지되어야 하기에 다른 메소드 처럼 스택이 아니라 따로 힙에 저장된다.
힙을 사용해서 메모리를 활용하기에 너무 많은 코루틴을 생성하면 힙은 할당하는 시간이 더 오래 걸리기에 성능에 안좋은 영향을 끼칠 수 있다.   
그래서 코루틴이 종료되지 않고 계속 진행될 경우 차라리 update에서 해당 반복을 실행하는 것이 현명하다.  
<br>

## 사용법
```
 StartCoroutine(FadeAndLoadSceneRoutine());
```
이렇게 실행시키고   

```
IEnumerator FadeAndLoadSceneRoutine()
   {
       float alpha = 0f;
       while (alpha < 1f)
       {
           alpha += fadeSpeed * Time.deltaTime;
           fadeCanvasGroup.alpha = alpha;
           yield return null;
       }
       yield return new WaitForSeconds(0.5f);
       SceneManager.LoadScene(sceneToLoadIndex);
   }
```
이렇게 만든다.   
yield로 return하면 한 frame이 끝나고 해당 코루틴안에 실행할게 남아있으면 코루틴으로 돌아온다.  
yield return은 코루틴안의 실행을 멈추고 유니티에게 권한을 넘겨주는 것이다.  
yield return 뒤에 오는 내용은 언제까지 멈출지를 나타내는 것으로 이 조건이 만족할 때 까지 유니티는 다른 코드를 실행한다.  
<br>
```
StartCoroutine(coroutine);
```
이걸로 정지 시킬 수도 있다.   
코루틴 스크립트가 적용된 GameObject를 SetActive로 꺼버리거나, Destroy 해도 정지된다.  

<br>
## yield return 값들
null : Update 끝나면 실행
WaitForEndOfFrame : 한 프레임이 종료되고 화면 렌더링이 끝났을 때
new WaitForSeconds(.1f) : timeScale상 시간이 흐를때까지
WaitForRealTime() : 실제 시간이 흘렀을 때
WailtUntil(bool) : 해당값이 true 일때
WaitWhile(bool) : 해당 값이 false일 때
StartCoroutine() : 이 안에서 실행한 다른 코루틴이 종료될 때

## 추천되는 사용 경우  
1. 성능에 크게 구애받지 않는 경우(턴제 게임 등)  
2. fading out을 하며 다음 scene으로 로드될 때  
3. http 데이터 전송, I/O 등 병렬적 일처  

<br>
# 팀 프로젝트 ROBO BLASTER 발표
