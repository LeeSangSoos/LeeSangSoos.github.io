---
layout: single
title: "내일배움캠프 82일차 TIL + 버그 잡기"
permalink: /2024/08/09/TIL/
tags: [TIL, 내일배움캠프, 스파르타내일배움캠프, 스파르타내일배움캠프TIL, Unity]
---

# 작업 내용
## 버그 잡기
오늘은 유저테스트를 위해 마무리 버그잡기를 했는데, 우선 레이어 마스크 에러가 있었다.  
```
LayerMask uilayer = LayerMask.GetMask("UI");
```
이렇게 받아온 정보를 게임 오브젝트의 레이어와 비교했는데 문제는 레이어마스크는 비트값을 가져와서 index 5인 레이어의 값이 32로 가져와진다는 것이다.  
그래서 UI 레이어를 판별하지 못해 UI를 누를 때와 게임 필드를 누를 경우를 판별 못했다.  
그래서 NameToLayer로 레이어 index값을 정상적으로 가져와 비교하였다. 물론 이전에 만든 상수 모음집을 썼다.  
```
if (result.gameObject.layer == Constants.Layers.UI)
```
그리고 게임이 끝나면 현재 웨이브를 가져와야하는데 그 기능을 안만들어서 무조건 마지막 웨이브인 웨이브 10이라는 정보만 나왔는데 이 로직을 변경했다.  
또 재시작을 씬 리로드가 아니라 직접 불필요한 데이터만 치우고 다시 시작하게 만들어서 불필요한 오브젝트를 모두 치워줘야하는데 개발하다보니 그런 오브젝트가 쌓였다.  
대표적으로 투사체나 스킬 이펙트 오브젝트들이 재시작하면 비활성화 되어야해서 해주었다.  
다른 문제는 StateMachine이 Monobehaviour가 아니라서 재시작하면 유닛이 파괴될 때 스테이트가 동작하며 사라진 오브젝트들을 참조하여 null에러가 났다.  
그래서 어떻게하면 유닛이 파괴된걸 Monobehaviour가 없는 스테이트머신에게 알릴까 고민하다가 유닛이 파괴될 때 OnDestroy에 스테이트를 모두 null로 바꿔주니 문제가 해결되었다.  
```
 private void OnDestroy()
    {
        StateMachine = null;

        // 루트
        IdleState = null;

        // 1층 브랜치
        MovingAttackState = null;
        TrackingState = null;
        JustMoveState = null;

        // 2층 브렌치
        MoveState = null;

        // 리프 브랜치
        AttackState = null;
    }
```
또 스테이지 선택 씬에서 인덱스를 잘못 넣어서 스테이지 1만 깼는데 2도 같은 숫자를 써서 같이 깨지는 등의 오류도 고쳤다.  
영웅도 영웅 ID를 매번 잘 넣어줬어야했는데, 해금만 하고 게임에서는 유닛을 무작정 순서대로 해금시켜서 해금한 영웅이 제대로 나오지 않았다. 이러한 실수도 고쳤다.  
마지막으로 유닛이 이동을 반절만 하는 문제가 있었다.  
```
timeLimit = agent.remainingDistance / agent.speed + 1.0f;
```
기존에 MoveState에서는 이렇게 시간제한을 계산했는데 이러니까 유닛들이 멀리 이동하면 반절만 이동했다.  
길 자체가 꺾이면 당연히 제대로 계산할 수 없고, 또 이러한 계산이 실제 이동 시간이랑 꼭 맞지는 않기에 당연한 결과였다.  
그래서 유닛 이동을 고치려고 이 방법 저 방법 많이 고민하다가 결과적으로 agent.remainDistance가 제대로 된 결과를 내지 못하고 멀리 이동하라고 찍어도 남은 거리가 소수점이 되는 기괴한 현상이 발생하는 것을 알았다. agent에 목적지 설정하기전에 목적지 vector값과 현재 유닛 vector값을 모두 확인했기에 내 코드 문제가 아니라 agent계산식 문제인 것은 확실하다.  
그래서 대신 직접 목적지까지 거리를 Vector2.Distance로 구해서 시간 제한을 줬고 조금 여유롭게 줬다.  
```
 timeLimit = Vector2.Distance(userUnit.Action.TargetPosition, userUnit.transform.position) * 1.5f / agent.speed;
```
그리고 이를 고칠 때 agent.velocity도 써보았는데 이건 정말 쓰면 안되는게 에이전트가 상태에 따라 현재속도가 변할 수 있어서 현재 속도에 따라 도착지점까지 남은 시간이 무한대가 나올 때도 있다.  

# 마무리
오늘은 버그만 잡다가 어느정도 우리 팀의 눈에 띄는 버그들을 다 고치고 유저테스트를 위해 itch.io에 배포하였다. 주말을 지나면 이런저런 유저들의 버그 리포트가 올랄올텐데 기대도 되고 걱정도 된다. 그리고 하스스톤 UI를 참고하려고 이전에 구경하다가 배운것이 하스스톤은 유저의 input을 받으면 내부적 계산을 처리하고 애니메이션을 그 다음에 보여줬다.  
이러한 방법은 나중에 게임을 만들 때도 유용하게 사용될 수 있을 것 같다.
