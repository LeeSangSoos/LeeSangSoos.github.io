---
layout: single
title: "내일배움캠프 59일차 7/09 TIL + Grid로 이동 기능 대체"
permalink: /2024/07/09/TIL/
tags: [TIL, 내일배움캠프, 스파르타내일배움캠프, 스파르타내일배움캠프TIL, Unity, Grid]
---

# 작업 내용
## 그리드로 기존의 이동 기능들 대체
그리드로 기존의 이동 기능들을 대체하였다.  
일단 기존의 코드를 최대한 수정하지 않는 방향으로 했는데, 개발 진행 속도면에서도 좋지만, 충돌 가능성도 적다. 물론 이러면 코드가 지저분해지고 비효율적일 수 있기에 다음 주에는 팀원들 모두 같이 코드 리펙토링을 하며 코드를 개선할 생각이다.  
중요한 변화는 기존에는 agent의 목적지를 설정 해주면 NavMesh 에서 알아서 이동 해주었기에 목적지만 설정해주었으면 됐지만, 이제는 자동으로 매 프레임 이동해주지 않기에 update에서 직접 이동해주어야 한다. 그렇다보니 기존의 agent 목적지만 바꿔주던 Move 관련 함수를 바꾸어야했다. 이동과 관련된 State들은 direction과 speed를 State Enter시에 계산을 하였다.  
```
public override void Enter()
{
    userUnit.Action.IsAlert = true;
    userUnit.Action.IsOnTheMove = true;
    userUnit.Action.IsTracking = false;

    targetPos = userUnit.Action.TargetPosition;
    direction = (targetPos - (Vector2)userUnit.transform.position).normalized;
    speed = userUnit.Stat.MovementSpeed.TotalValule;
}
```
UserUnitAction 클래스에 MoveToTarget()은 이제 direction과 speed만 받아서 이동하며 class의 필드에 targetPosition으로 거리를 계산해서 도착을 계산하고 도착하면 false를 return해서 끝나는지를 판단한다.  
```
public bool MoveToTarget(Vector2 direction, float speed)
{
    if (Vector2.Distance(targetPosition, transform.position) <= speed * Time.deltaTime){
        transform.position = targetPosition;
        return false;
    }
    transform.Translate(direction * speed * Time.deltaTime, Space.World);
    return true;
}
```
이유는 이렇게 해야 Update로 이동이 가능하고, direction과 speed는 Update 전에 이미 계산이 가능하기에 미리 계산해서 이 값만 계속 넘겨주어 업데이트 하는 것이다.  
가장 기본적인 UserUnitMoveState에서는 이를 이용해서 Update를 해준다.  
```
public override void Update()
{
    if(!userUnit.Action.MoveToTarget(direction, speed))
    {
        userUnit.StateMachine.ChangeState(userUnit.IdleState);
    }
}
```
UserUnitMoveingAttackState에서도 적이 있는지 판단하고 없거나 죽었으면 비슷하게 이동을 진행한다.  
```
public override void Update()
{
    // 이동 중이었으면 도착지점에 도착 했을 경우 이동을 취소하고 공격 준비 상태로 돌입
    // 적이 있으면 이동하지 않음
    if(userUnit.Action.TargetEnemy == null || userUnit.Action.TargetEnemy.Dead)
    {
        if(!userUnit.Action.MoveToTarget(direction, speed)){
            userUnit.StateMachine.ChangeState(userUnit.IdleState);
        }
    }
}
```
확실히 Update로 이동을 직접 전부 통제하니까 이동 제어가 훨씬 쉬워져서 공격시에도 Stop을 이용해 agent를 수정해줘야 했는데, 이제는 그냥 이동을 멈추면 된다.  
게다가 목적지는 수정하지 않으니 다시 이동할 때도 코드가 위와 같이 간단하게 계속 Update해주기만 하면 된다.  
UserUnitTrackingState 클래스도 수정되었는데, 이번에는 적의 위치에 따라 direction이 바뀌어야 하기에 이번에는 목적지와 방향을 매번 새로 계산해준다. 물론 적과 거리가 떨어져서 이동해야할 경우만이다.  
```
public override void Update()
{
    // 적을 추적 중이면 사거리 밖으로 나간 적 매번 적의 위치 갱신
    // 적이 죽거나 없으면 Idle로 상태 전환
    if (userUnit.Action.TargetEnemy == null || userUnit.Action.TargetEnemy.Dead)
    {
        userUnit.StateMachine.ChangeState(userUnit.IdleState);
    }
    else if((Vector2.Distance(userUnit.Action.TargetEnemy.transform.position, userUnit.transform.position) > userUnit.Stat.AttackRange.TotalValule))
    {
        Vector2 directionToEnemy = (userUnit.Action.TargetEnemy.transform.position - userUnit.transform.position).normalized;
        Vector2 targetPosition = ((Vector2)userUnit.Action.TargetEnemy.transform.position) - directionToEnemy * (userUnit.Stat.AttackRange.TotalValule - 0.1f);

        userUnit.Action.TargetPosition = targetPosition;
        userUnit.Action.MoveToTarget(directionToEnemy, speed);
    }
}
```
이제는 NavMesh를 제거하고 그리드만으로 동작을 한다.  
![스크린샷 2024-07-09 195927](https://github.com/LeeSangSoos/LeeSangSoos.github.io/assets/105085706/68453f79-e2b2-4ccb-986e-5cb0827432c6)  

# 마무리
문제는 단체 이동과 같은 경우 서로 겹치지않게 정렬을 해주어야하는데, 그러려면 유닛들의 위치를 그리드에 저장하고 언제나 다른 유닛이 해당 자리로 이동하려할 때 검사하여 위치로 이동하는 위치를 가능한 위치로 바꾸어야한다.  
그런데 지금은 단순히 직선으로 이동하기에 이동 중에 홀드, 공격 종료, 이동 방향 변경 등으로 위치가 변형될 경우 그리드 중간에 걸친다. 그렇기에 언제나 유닛들이 그리드에 존재하도록 하기 위해 길찾기 기능을 이용해서 유닛들이 언제나 그리드 위에서 매 프레임 움직이게 해야한다. 그래서 A* 알고리즘을 이용해서 길찾기를 만들 계획이다.  
