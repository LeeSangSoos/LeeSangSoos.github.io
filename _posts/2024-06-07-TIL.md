---
layout: single
title: "내일배움캠프 37일차 6/07 TIL + Unity공부"
permalink: /2024/06/07/TIL/
tags: [TIL, 내일배움캠프, 스파르타내일배움캠프, 스파르타내일배움캠프TIL, Unity]
---

# Mixamo에서 캐릭터 받아오기
## 캐릭터 가져오기
![스크린샷 2024-06-07 141013](https://github.com/LeeSangSoos/LeeSangSoos.github.io/assets/105085706/96d37706-5dd8-400b-8ef7-6b67d5d98d29)  
로그인을 하고 캐릭터를 유니티 버전, T자 모양으로 다운 받는다.  
![스크린샷 2024-06-07 141124](https://github.com/LeeSangSoos/LeeSangSoos.github.io/assets/105085706/3c1d9711-2377-4ab1-a97f-e00c39436fb1)  
그 다음 Rig 세팅을 휴머노이드로 해주고, 에러가 뜨면 인스펙터창에 Configure에 들어가서 부족한 부위에 몸을 할당해준다.  
![스크린샷 2024-06-07 141220](https://github.com/LeeSangSoos/LeeSangSoos.github.io/assets/105085706/08fb802a-614b-4648-acaf-c3bcd77997fe)  
<br>
## 애니메이션 가져오기
![스크린샷 2024-06-07 141256](https://github.com/LeeSangSoos/LeeSangSoos.github.io/assets/105085706/78d6b8a8-87cf-4d08-951b-f7ecae3af088)  
그 다음 애니메이션은 스킨은 이미 캐릭터가 있으니 없애고, 유니티 버전으로 원하는 fps로 가져온다.  
![스크린샷 2024-06-07 141343](https://github.com/LeeSangSoos/LeeSangSoos.github.io/assets/105085706/accfb97d-35e8-4f5f-abc0-cc4ffe65d4fa)  
스킨도 똑같이 Rig에서 휴머노이드로 설정해주고, 이번에는 Avater Definition을 다른데서 가져오기를 선택하고 다운 받은 캐릭터 모델을 가져온다.  
나머지는 다른 애니메이셔이랑 똑같이 애니메이션 컨틀롤러 만들어주고 애니메이션을 넣어준다

# 컴퓨터 구조와 GPU
CPU에서 GPU로 일을 시키는데, 드로우콜을 사용해서 한번에 묶어서 일을 시킨다.  
GPU는 병렬적으로 간단한 계산을 한번에 많이 실행하여 요즘같이 늘어나는 해상도의 시대에 수많은 픽셀들을 한번에 계산해서 그래픽을 연산하는데 잘 쓰인다.  
GPU안에는 10000개 가량의 코어가 존재하여 한번에 수많은 연산을 한다.  
<br>
그렇게 수 많은 점들 vertiex를 연산하여 월드 스페이스에서 2d 스페이스로 이동 시키면 화면에 랜더링 하기 위한 첫번째 단계가 끝난다.  
<br>
그 다음 단계는 Rasterization으로 이렇게 선분들을 계산하여 가져왔을 때 각 삼각형이 화면의 몇 픽셀을 차지하는지 계산하는 것이다.  
이 또한 GPU가 화면에 있는 점들의 좌표를 이용해 각 삼각형이 필요한 픽셀 위치를 구한다.  
우리가 기억해야할 것은 그래픽은 실제로 수많은 점들과 그 점들을 이어서 만들어진 삼각형들로 이루어져있다.  
그렇게 하나의 삼각형의 픽셀들을 같은 색으로 칠하고 나면 옆에 삼각형으로 이동해서 그렇게 반복하여 모든 삼각형들의 색을 다 표현한다.  
문제는 실제로는 물체의 뒤에도 3d의 경우는 삼각형들이 존재하는데 어떤 삼각형을 화면에 표시할지가 중요하다.  
이는 Z-Buffer는 카메라에서 거리를 각 픽셀에 무게로 주어 이 거리가 Z방향이라 Z-Bufffer다.  
그리고 각 삼각형들은 Depth-Buffer라는 카메라에서 게임속 삼각형이 얼마나 떨어졌는지 값을 가지고있는데, 이게 Z-Buffer보다 작으면 앞에 표시하고,  
크면 뒤에 표시한다.  
말 그대로 카메라에서 거리를 계산하여 표현하는거다.  
문제는 삼각형이 카메라에 수직이 아니기에 각 픽셀별로 또 하나의 삼각형안에 있더라도 해당 픽셀 위치에서 그보다 더 작은 픽셀값이 다른 삼각형에 존재하면 그 부분만 변형하여 자연스럽게 표현한다.  
<br>
이러다보면 픽셀별로 다 색을 정해주면 삼각형들이 삼각형이 아니라 픽셀게임 처럼 네모들로 울퉁불퉁한 모양이 될 것이다.  
이럴 때 쓰는 방법이 SSAA(Super Sampling Anti-Aliasing)이다.  
이는 픽셀 하나를 또 16등분 하여 그 안에 얼마만큼 삼각형에 포함 되는지를 나눠 그 비율에 따라 해당 픽셀의 색을 결정해주는 것이다.  
그래서 끝 부분은 색이 연해지며 픽셀게임 같은 모양이 아닌 부드러운 고급 이미지가 나오는 것이다.  
<br>
마지막은 Fragment shading이다.  
이건 이름 그대로 그림자와 빛의 반사를 적용하여 지금까지 계산한 픽셀 색을 좀 더 현실적으로 발전 시키는 과정이다.  
참고로 Fragment는 픽셀들로 이루어진 앞에서 말한 작은 삼각형 1개이다.  
핵심은 빛을 바라보면 밝아지고, 빛에 수직이거나 반대면 어두워 진다는 것이다.  
그래서 빛의 방향, 표면의 수직 방향을 알아야한다.  
그 두 방향의 각도에 코사인을 가져와서 색, 빛의 강도를 곱해서 그 색에 맞는 명도를 준다.  
문제는 각도에 따라 음수가 나올 수 있기에 이를 방지하기 위해 코사인 최소값은 0 이다.  
그리고 색과 주위 빛강도를 곱해서 더해주어 낮에는 빛과 각도가 안맞아도 조금 밝게, 밤에는 진짜 안보이도록 어둡게 만든다.  
그리고 광원이 많으면 이 계산을 여러번 하여 그 값들을 비율에 맞춰 더하고 대신 빛 마다 범위 제한이 있어 멀리있는 물체에는 영향을 못주게 한다.  
<br>
문제는 이러면 삼각형마다 1가지 빛 반사 결과값을 적용받아 부자연스러울 수 있다.  
그렇기에 각 점인 vertex마다 수직 방향을 구하여 삼각형 면의 수직방향 대신 쓴다.  
그리고 삼각형 별로 그 점들에서 나온 수직 방향들 안에 면에도 수많은 수직 방향들을 구해서 아주 세세하게 빛을 계산해준다.
